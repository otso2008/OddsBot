<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Odds Analysis</title>
  <style>
    body { margin:0; font-family: Arial, sans-serif; background:#ffffff; color:#222222; padding-bottom: 70px; }
    .view { display:none; padding:1rem; min-height: calc(100vh - 60px); box-sizing:border-box; }
    nav { position: fixed; bottom: 0; left: 0; right: 0; height: 60px; display:flex; border-top:1px solid #ccc; background:#ffffff; }
    nav button { flex:1; border:none; background:transparent; font-size:1rem; color:#333; padding:0.5rem 0; cursor:pointer; }
    nav button.active { color:#0070c9; border-top:2px solid #0070c9; font-weight:bold; }
    h2 { font-size:1.2rem; margin:1rem 0 0.5rem 0; }
    h3 { font-size:1rem; margin:1rem 0 0.5rem 0; }
    .card { border:1px solid #eeeeee; border-radius:8px; padding:0.7rem; margin-bottom:0.7rem; box-shadow:0 1px 2px rgba(0,0,0,0.05); background:#fff; }
    .card-header { font-weight:bold; }
    .ev-positive { color: #008000; }
    .ev-neutral { color: #555555; }
    .ev-negative { color: #cc0000; }
    table { width:100%; border-collapse:collapse; margin-top:0.5rem; }
    th, td { border:1px solid #e0e0e0; padding:0.4rem; text-align:center; font-size:0.9rem; }
    th { background:#f9f9f9; font-weight:bold; }
    .no-vig-row { background:#f0f0f0; font-weight:bold; }
    small { display:block; font-size:0.75rem; }
    input[type="checkbox"] { margin-right:0.4rem; }
    button { background-color:#f0f0f0; border:1px solid #cccccc; padding:0.5rem 1rem; border-radius:6px; cursor:pointer; }
    button:hover { background-color:#e6e6e6; }
    .filter { margin-bottom:0.5rem; }
  </style>
</head>
<body>
  <div id="homeView" class="view"></div>
  <div id="evView" class="view"></div>
  <div id="arbView" class="view"></div>
  <div id="matchView" class="view"></div>
  <nav id="bottomNav">
    <button data-view="homeView" class="active">Etusivu</button>
    <button data-view="evView">+EV</button>
    <button data-view="arbView">Arbitraasit</button>
  </nav>
  <script>
  (function(){
    const API_BASE = "";
    const API_KEY = "Goala411";
    const AFFILIATE_MAP = (function(){ try { return JSON.parse('{{AFFILIATE_MAP}}'); } catch(e){ return {}; }})();
    const homeView = document.getElementById('homeView');
    const evView = document.getElementById('evView');
    const arbView = document.getElementById('arbView');
    const matchView = document.getElementById('matchView');
    const navButtons = document.querySelectorAll('#bottomNav button');

    function showView(viewId){
      [homeView, evView, arbView, matchView].forEach(div => {
        div.style.display = div.id === viewId ? 'block' : 'none';
      });
      navButtons.forEach(btn => {
        if (btn.dataset.view === viewId) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
    }
    navButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const viewId = btn.dataset.view;
        if(viewId === 'homeView'){ loadHome(); }
        else if(viewId === 'evView'){ loadEv(); }
        else if(viewId === 'arbView'){ loadArb(); }
        showView(viewId);
      });
    });
    // fetch helper
    async function fetchJSON(path, params={}){
      const url = new URL((API_BASE || '') + path, window.location.origin);
      Object.keys(params).forEach(k => {
        const v = params[k];
        if(v !== undefined && v !== null) url.searchParams.append(k, v);
      });
      const headers = {};
      if (API_KEY) headers['X-API-Key'] = API_KEY;
      const res = await fetch(url.toString(), { headers });
      if(!res.ok) throw new Error('API error '+res.status);
      return await res.json();
    }
    // Home page
    async function loadHome(){
      // load matches
      let matches;
      try {
        matches = await fetchJSON('/api/matches/upcoming');
      } catch(err){
        homeView.innerHTML = '<p>Virhe ladatessa otteluita.</p>';
        return;
      }
      const leagues = {};
      matches.forEach(m => {
        if(!leagues[m.league]) leagues[m.league] = [];
        leagues[m.league].push(m);
      });
      // load preview EV and arb
      let evPreview=[], arbPreview=[];
      try { evPreview = await fetchJSON('/api/ev/top', { limit: 5 }); } catch(e){}
      try { arbPreview = await fetchJSON('/api/arbs/latest', { limit: 5 }); } catch(e){}
      let html = '';
      html += '<h2>Liigat</h2>';
      const leagueNames = Object.keys(leagues);
      if(leagueNames.length === 0){
        html += '<p>Ei otteluita.</p>';
      } else {
        leagueNames.sort().forEach(league => {
          html += '<div class="card league-card" data-league="'+league+'">';
          html += '<div class="card-header">'+league+'</div>';
          html += '</div>';
        });
      }
      html += '<h2>Parhaat +EV</h2>';
      if(evPreview.length === 0) html += '<p>Ei +EV-kohteita.</p>';
      else {
        evPreview.slice(0,5).forEach(item => {
          const evPct = (item.ev_fraction * 100).toFixed(1);
          const cls = evPct > 2 ? 'ev-positive' : (evPct < -2 ? 'ev-negative' : 'ev-neutral');
          html += '<div class="card ev-preview" data-match-id="'+item.match_id+'">';
          html += '<div><strong>'+item.home_team+' vs '+item.away_team+'</strong></div>';
          html += '<div>'+item.bookmaker_name+' '+item.market_code+' '+item.outcome+' @ '+item.odds.toFixed(2)+'</div>';
          html += '<div class="'+cls+'">EV '+(evPct>0?'+':'')+evPct+'%';
          html += '</div>';
          html += '</div>';
        });
      }
      html += '<h2>Parhaat Arbitraasit</h2>';
      if(arbPreview.length === 0) html += '<p>Ei arbitraaseja.</p>';
      else {
        arbPreview.forEach(item => {
          const roi = (item.roi_fraction * 100).toFixed(2);
          html += '<div class="card arb-preview" data-match-id="'+item.match_id+'">';
          html += '<div><strong>'+item.home_team+' vs '+item.away_team+'</strong></div>';
          html += '<div>ROI '+(roi>0?'+':'')+roi+'%</div>';
          html += '</div>';
        });
      }
      homeView.innerHTML = html;
      // attach handlers
      homeView.querySelectorAll('.league-card').forEach(div => {
        div.addEventListener('click', () => {
          const league = div.dataset.league;
          showLeagueMatches(leagues[league], league);
        });
      });
      homeView.querySelectorAll('.ev-preview').forEach(div => {
        div.addEventListener('click', () => {
          showMatch(div.dataset.matchId);
        });
      });
      homeView.querySelectorAll('.arb-preview').forEach(div => {
        div.addEventListener('click', () => {
          showMatch(div.dataset.matchId);
        });
      });
    }
    function showLeagueMatches(matches, league){
      let html = '<h2>'+league+'</h2>';
      if(matches.length === 0){
        html += '<p>Ei otteluita.</p>';
      } else {
        matches.forEach(m => {
          const time = new Date(m.start_time).toLocaleString();
          html += '<div class="card match-list-item" data-match-id="'+m.match_id+'">';
          html += '<div>'+m.home_team+' vs '+m.away_team+'</div>';
          html += '<div>'+time+'</div>';
          html += '</div>';
        });
      }
      html += '<button id="backHome">Takaisin</button>';
      homeView.innerHTML = html;
      homeView.querySelector('#backHome').addEventListener('click', loadHome);
      homeView.querySelectorAll('.match-list-item').forEach(div => {
        div.addEventListener('click', () => {
          showMatch(div.dataset.matchId);
        });
      });
    }
    let evData = [];
    async function loadEv(){
      try {
        evData = await fetchJSON('/api/ev/top', { limit: 50 });
      } catch(err){
        evView.innerHTML = '<p>EV-datan lataus epäonnistui.</p>';
        return;
      }
      if(!evData || evData.length === 0){
        evView.innerHTML = '<p>Ei +EV-kohteita.</p>';
        return;
      }
      const books = Array.from(new Set(evData.map(item => item.bookmaker_name))).sort();
      let html = '<div class="filter"><strong>Bookkerit:</strong> ';
      books.forEach(book => {
        html += '<label><input type="checkbox" class="book-filter" value="'+book+'" checked> '+book+'</label> ';
      });
      html += '</div>';
      html += '<div id="evList"></div>';
      evView.innerHTML = html;
      evView.querySelectorAll('.book-filter').forEach(input => {
        input.addEventListener('change', renderEvList);
      });
      renderEvList();
    }
    function renderEvList(){
      const selected = Array.from(evView.querySelectorAll('.book-filter'))
        .filter(i => i.checked)
        .map(i => i.value);
      const container = evView.querySelector('#evList');
      let html = '';
      evData.filter(item => selected.includes(item.bookmaker_name))
        .forEach(item => {
          const evPct = (item.ev_fraction * 100).toFixed(1);
          const cls = evPct > 2 ? 'ev-positive' : (evPct < -2 ? 'ev-negative' : 'ev-neutral');
          html += '<div class="card ev-item" data-match-id="'+item.match_id+'">';
          html += '<div><strong>'+item.home_team+' vs '+item.away_team+'</strong></div>';
          html += '<div>'+item.market_code+' / '+item.outcome+' – '+item.bookmaker_name+'</div>';
          html += '<div>Kerros '+item.odds.toFixed(2)+', Fair '+(1/item.fair_probability).toFixed(2)+'</div>';
          html += '<div class="'+cls+'">EV '+(evPct>0?'+':'')+evPct+'%</div>';
          html += '</div>';
        });
      container.innerHTML = html || '<p>Ei kohteita valituilla bookkereilla.</p>';
      container.querySelectorAll('.ev-item').forEach(div => {
        div.addEventListener('click', () => {
          showMatch(div.dataset.matchId);
        });
      });
    }
    let arbData = [];
    async function loadArb(){
      try {
        arbData = await fetchJSON('/api/arbs/latest', { limit: 50 });
      } catch(err){
        arbView.innerHTML = '<p>Arbitraasien lataus epäonnistui.</p>';
        return;
      }
      if(!arbData || arbData.length === 0){
        arbView.innerHTML = '<p>Ei arbitraaseja.</p>';
        return;
      }
      let html = '';
      arbData.forEach(item => {
        const roiPct = (item.roi_fraction * 100).toFixed(2);
        html += '<div class="card arb-item" data-match-id="'+item.match_id+'">';
        html += '<div><strong>'+item.home_team+' vs '+item.away_team+'</strong></div>';
        html += '<div>ROI '+(roiPct>0?'+':'')+roiPct+'%</div>';
        const legs = Object.keys(item.legs).map(o => {
          const leg = item.legs[o];
          return o+': '+leg.book+' '+leg.odds.toFixed(2);
        }).join(' | ');
        html += '<div>'+legs+'</div>';
        html += '</div>';
      });
      arbView.innerHTML = html;
      arbView.querySelectorAll('.arb-item').forEach(div => {
        div.addEventListener('click', () => {
          showMatch(div.dataset.matchId);
        });
      });
    }
    async function showMatch(matchId){
      showView('matchView');
      matchView.innerHTML = '<p>Ladataan...</p>';
      try {
        const [oddsList, fairList] = await Promise.all([
          fetchJSON('/api/odds/'+matchId),
          fetchJSON('/api/fair/'+matchId)
        ]);
        // Find match info if available
        let matchInfo = null;
        if(evData) matchInfo = evData.find(m => m.match_id == matchId);
        if(!matchInfo && arbData) matchInfo = arbData.find(m => m.match_id == matchId);
        // Build markets map
        const marketMap = {};
        fairList.forEach(f => {
          const key = f.market_code + ((f.line !== null && f.line !== undefined) ? ':'+f.line : '');
          if(!marketMap[key]) marketMap[key] = { market_code: f.market_code, line: f.line, outcomes: {}, fairRef: f.reference_bookmaker_name };
          if(!marketMap[key].outcomes[f.outcome]) marketMap[key].outcomes[f.outcome] = {};
          marketMap[key].outcomes[f.outcome].fairProb = f.fair_probability;
          marketMap[key].outcomes[f.outcome].noVigOdds = f.no_vig_odds;
        });
        oddsList.forEach(o => {
          const key = o.market_code + ((o.line !== null && o.line !== undefined) ? ':'+o.line : '');
          if(!marketMap[key]) marketMap[key] = { market_code: o.market_code, line: o.line, outcomes: {}, fairRef: null };
          if(!marketMap[key].outcomes[o.outcome]) marketMap[key].outcomes[o.outcome] = {};
          if(!marketMap[key].outcomes[o.outcome].oddsByBook) marketMap[key].outcomes[o.outcome].oddsByBook = {};
          marketMap[key].outcomes[o.outcome].oddsByBook[o.bookmaker_name] = o.price;
        });
        let html = '';
        if(matchInfo){
          const time = new Date(matchInfo.start_time).toLocaleString();
          html += '<h2>'+matchInfo.home_team+' vs '+matchInfo.away_team+'</h2>';
          html += '<p>'+time+'</p>';
        } else {
          html += '<h2>Match '+matchId+'</h2>';
        }
        const keys = Object.keys(marketMap);
        keys.sort();
        keys.forEach(key => {
          const market = marketMap[key];
          const outcomes = Object.keys(market.outcomes);
          // gather unique bookmakers for this market
          const booksSet = new Set();
          outcomes.forEach(out => {
            const ob = market.outcomes[out].oddsByBook || {};
            Object.keys(ob).forEach(b => booksSet.add(b));
          });
          const books = Array.from(booksSet).sort();
          html += '<h3>'+market.market_code + ((market.line !== null && market.line !== undefined) ? ' '+market.line : '')+'</h3>';
          html += '<table>';
          html += '<thead><tr><th></th>';
          outcomes.forEach(out => { html += '<th>'+out+'</th>'; });
          html += '</tr></thead><tbody>';
          // no-vig row
          html += '<tr class="no-vig-row"><td>No-vig</td>';
          outcomes.forEach(out => {
            const noVig = market.outcomes[out].noVigOdds;
            html += '<td>' + (noVig ? noVig.toFixed(2) : '-') + '</td>';
          });
          html += '</tr>';
          // book rows
          books.forEach(book => {
            html += '<tr><td>'+book+'</td>';
            outcomes.forEach(out => {
              const odds = (market.outcomes[out].oddsByBook && market.outcomes[out].oddsByBook[book]);
              const fairProb = market.outcomes[out].fairProb;
              let evPct = null;
              if(odds && fairProb){ evPct = (odds * fairProb - 1) * 100; }
              let cls = '';
              if(evPct !== null){ cls = evPct > 2 ? 'ev-positive' : (evPct < -2 ? 'ev-negative' : 'ev-neutral'); }
              html += '<td class="'+cls+'">';
              html += (odds ? odds.toFixed(2) : '-');
              if(evPct !== null){
                html += '<small>EV '+(evPct>0?'+':'')+evPct.toFixed(1)+'%</small>';
              }
              html += '</td>';
            });
            html += '</tr>';
          });
          html += '</tbody></table>';
        });
        html += '<button id="backHomeBtn">Takaisin</button>';
        matchView.innerHTML = html;
        document.getElementById('backHomeBtn').addEventListener('click', () => {
          showView('homeView');
          loadHome();
        });
      } catch(err){
        matchView.innerHTML = '<p>Virhe ladattaessa ottelua.</p>';
      }
    }
    window.addEventListener('DOMContentLoaded', () => {
      showView('homeView');
      loadHome();
    });
  })();
  </script>
</body>
</html>
